---
title: '【浅显易懂系列】3D高斯完整入门'
date: 2025-05-31
permalink: /posts/2025/05/3DGS/
tags:
  - 3D Gaussian
  - NeRF神经辐射场
  - 三维重建
  - 相机位姿先验
  - 多视角重建
---

# $\dagger$ 一个教程全部读懂3D高斯
##### $\textbf{【注意】}\textcolor{red}{本教程由曹逸飞撰写，转载需引用}$
## 一、$\dagger$ 3D Gaussian Splating介绍 【打基础】

## 一句话解释3D高斯泼溅：使用3D gaussian秋表示三维模型，并通过splating技术渲染出来

- $\dagger$ 原始论文介绍
```《3D Gaussian Splatting for Real-Time Radiance Field Rendering》这篇论文由 Bernhard Kerbl, Georgios Kopanas, Thomas Leimkühler, 和 George Drettakis 等人在2023年发表，并在计算机图形学领域引起了广泛关注，因为它在保持高质量渲染的同时，实现了新视角合成的实时性能。基于这篇论文开启3D高斯的时代。如下是对3D高斯泼溅的流程示意图，分为如下几个核心步骤：1）输入照片 → SfM 得到稀疏点云；2）点云包裹成初始 3D 高斯椭球；3）优化阶段：高斯被拉伸、移动、改颜色；4）自适应：有需要的地方高斯分裂 / 克隆；无用的被剪枝；5）瓦片光栅化：高斯投影成 2D 椭圆并分 tile 进行前后混合；6）实时渲染：得到最终可交互视图```

![alt text](image-6.png)

### 1.1 摘要 (Abstract)
论文的摘要指出，先前的新视角合成方法要么渲染质量高但速度慢（如NeRF及其许多变体），要么渲染速度快但质量有所牺牲。这篇论文提出了一种新的方法，通过使用3D高斯函数来表示场景，实现了高质量的渲染和实时的显示速度。

首先看核心思想（对于小白新手不理解，但别急，后面会解释每一个词儿的含义）：
1.  使用3D高斯来存储场景的几何和外观信息，每个高斯都有其位置、形状（通过各向异性协方差矩阵表示）、不透明度（alpha值）和颜色（通过球谐函数表示，以支持视角相关的效果）。
2.  从运动恢复结构（SfM）得到的稀疏点云开始初始化这些3D高斯。
3.  在优化过程中，交替进行高斯参数的优化和自适应的密度控制（即增加或删除高斯）。
4.  开发了一个快速的、可微分的基于瓦片（tile-based）的光栅化器，能够高效地将3D高斯“泼溅”（splatting）到图像平面上。

【通俗解释】我们现在开始通俗解释一下这几个含义：我们用大白话把这四个核心思想拆解开，讲讲每个专业名词是啥意思，它们具体是干嘛的。想象一下，我们要用电脑造一个跟真实世界一模一样的3D场景，比如一个房间。

---

**核心思想 1：使用3D高斯来存储场景的几何和外观信息，每个高斯都有其位置、形状（通过各向异性协方差矩阵表示）、不透明度（alpha值）和颜色（通过球谐函数表示，以支持视角相关的效果）。**

*   **大白话解释：**
    我们不用传统的积木块（比如三角形、正方形）来搭建这个3D房间，而是用很多很多微小的、彩色的、有特定形状的“3D小云彩”或者“3D小墨点”来把它堆出来。每一个“小云彩”都有它自己的特点。

*   **专业名词和具体内容：**
    1.  **3D高斯 (3D Gaussian)：**
        *   **含义：** 这就是我们说的“3D小云彩”或“3D小墨点”。它不是一个硬邦邦的点，而是一个在空间中弥散开的、有中心、有范围的分布。数学上，它是一个高斯函数在三维空间的表示。
        *   **公式概念：** 一个基础的高斯函数（未归一化的，因为我们更关心它的形状和影响范围），在认识之前先看看高斯函数的样子：
        
        ![alt text](image.png)
        ![alt text](image-5.png)
        ![alt text](image-1.png)
        ![alt text](image-4.png)
        ![alt text](image-2.png)
        ![alt text](image-3.png)

        我们接下来给出几种变换后的推导过程，从而能够直观的看到最终的表达形式：

        ![alt text](image-8.png)
        ![alt text](image-9.png)
        ![alt text](image-10.png)
        ![alt text](image-11.png)

        把变换矩阵A转换为协方差矩阵（表述随机变量两两之间的联合变动情况）：

        ![alt text](image-12.png)
        
        而高斯函数知道之后，我们再看高斯泼溅，这是一种光栅化技术，也就是计算机图形学中类似的三角形光栅化，这种用来在屏幕上绘制三角形，而现在是用高斯分布代替三角形呈现，如下对比：

        ![alt text](image-13.png)
        ![alt text](image-7.png)

        因此可以看到高斯的这种有这么几种参数：position点的位置（xyz，3D高斯中心值则是$μ$，、用均值表示）、颜色（RGB）、covariance mareix协方差（如何拉伸和缩放，3x3矩阵，决定高斯的形状）、opacity透明度（alpha透明度用于splating）、spherical harmonics球谐函数拟合视角相关的外观，下面可以看到高斯渲染和不透明的样子（有类似高斯椭球的样子）：

        ![alt text](image-15.png)
        ![alt text](image-16.png)

    2.  **3D高斯的位置 (Position, μ)：**
        *   **含义：** 就是这个“3D小云彩”的中心点在3D空间里的坐标 (x, y, z)。
        *   **公式体现：** $μ$

    3.  **3D高斯的形状（通过各向异性协方差矩阵表示, Shape represented by anisotropic covariance matrix）：**
        *   **含义：**
            *   **协方差矩阵 (Covariance Matrix, Σ)：** 这是一个3x3的数学矩阵，它精确地描述了这个“3D小云彩”的形状和朝向。它可以告诉我们这个“小云彩”在三个主方向上分别有多“胖”或多“瘦”，以及它在空间中是如何旋转的。
            *   **各向异性 (Anisotropic)：** 意思就是“小云彩”在不同方向上可以有不同的“胖瘦”。比如，它可以像一个鸡蛋（一个方向长，另两个方向短），而不是一个完美的球（各个方向一样）。这对于表达扁平的表面（比如墙面、桌面）或者细长的物体（比如柱子）非常重要。
        *   **公式体现：** $Σ$。为了方便优化，论文中通常不直接优化$Σ$的9个元素，而是优化一个缩放向量 $s$ (scale) 和一个旋转四元数 $q$ (rotation)。然后通过它们计算出$Σ$：$Σ = R S Sᵀ Rᵀ$，其中 $R$ 是从 $q$ 得到的旋转矩阵，$S$ 是由 $s$ 构成的对角缩放矩阵。这样能更好地控制形状。

    3.  **不透明度 (Opacity, α / alpha value)：**
        *   **含义：** 就是这个“小云彩”有多“实”。一个完全不透明的“小云彩”会完全挡住它后面的东西；一个半透明的“小云彩”则会透出一些后面的颜色。取值通常在0（完全透明）到1（完全不透明）之间。
        *   **公式体现：** $α$

    4.  **颜色（通过球谐函数表示，以支持视角相关的效果, Color represented by Spherical Harmonics for view-dependent effects）：**
        *   **含义：**
            *   **颜色 (Color)：** $C$表示，就是这个“小云彩”是什么颜色的。
            *   **球谐函数 (Spherical Harmonics, SH)：** 这是一种数学工具，可以用来描述一个东西从不同方向看过去颜色是怎么变化的。想象一个有光泽的金属球，你从正面看和从侧面看，它反射的光和颜色可能会不一样。球谐函数就能捕捉这种“视角相关的效果”。用它来表示颜色，可以让渲染出来的物体表面有更真实的光泽感和材质感。如下是球协函数的可视化，具体数学的推导不做说明，我们尽可能白话直观的进行解释和理解：
            ![alt text](image-17.png)
            下面是其数学的一个方程表示，感兴趣的可以参照下面的教程进行理解：[点击这里](https://zhuanlan.zhihu.com/p/430163791)
            ![alt text](image-18.png)

            
            - 【通俗白话的解释一下SH函数】归根到底它是一组基函数，至于这组基函数是怎么来的，不管它。我们都学过泰勒展开和傅里叶变换等，那么，这个基函数就不陌生了，比如下面的多项式$y_0=x^0$,$y_1=x$,$y_2=x^2$,$y_3=x^3$...。再比如三角函数$y_0=1$,$y_1=sin(x)$,$y_2=sin(2x)$,$y_3=sin(4x)$...，或者也可以随便去写自己的基函数，$y_0=555$,$y_1=x^3-666$...,这些基函数有了的话，我们可以用这些基函数组合加权去表示任何的函数，一般情况下，能用的基函数越多表达的能力也就越强，本质上看这就是一个有损的压缩，有点儿像是一个密码本，你一本我一本，上面都是基函数的定义，这样传密码本的时候只要传几个系数就可以了，系数传过来，就能复原出想要表达的函数，只是需要优化和精准而已。下面这个图像就特别明显的说明了一个黑色方波函数的信号通过一堆基函数的加权描述会越来越接近这个函数的样子：
            ![alt text](image-20.png)
            因此，这是二维的，三维中的球面坐标系上也这样，不用距离而用颜色表示的话就是不同的明暗程度的变化。而最最最有名的球面基函数就是这个球协函数了，球协函数的性质有很多，比如正交性，旋转不变性，正交性能够说明每一个基函数都是独立的，每一个基函数都不能用别的基函数加权得到，球协函数就长这样，其中蓝色的表示正数，而黄色表示负数，如下图所示：
            ![alt text](image-21.png)
            表达式的化长这样子：
            ![alt text](image-22.png)
            相信你看到这个应该和他一样的表情：
            ![alt text](image-23.png)
            那么我们如果把它退化到二维，就变成了下面这样，这个是示意图：
            ![alt text](image-24.png)
            现在看假如极坐标下的函数长这样，![alt text](image-25.png)，可以表示为$r=0.5+0.1cos\theta+0.25sin\theta+0.09cos\theta sin\theta+0.3（2cos\theta^2-1）$,只记函数的话，这个数字就是SH系数啦，当SH系数用的越多，那么表达能力也就越强，跟原始的函数就越来越接近。
            ![alt text](image-26.png)
            当用来描述不同方向的光照的SH基函数我们一般用到二阶或者三阶，更完整的表达和理解参照：[这里](https://zhuanlan.zhihu.com/p/351289217)。


        *   **公式体现：** 颜色通常用一组球谐系数来表示，例如 $c_{sh} = \{sh_0, sh_1, ..., sh_k\}$。当给定一个观察方向 $d$ 时，最终的颜色 $C = EvaluateSH(c_{sh}, d)$。

---

**核心思想 2：从运动恢复结构（SfM）得到的稀疏点云开始初始化这些3D高斯。**

*   **大白话解释：**
    在开始用“小云彩”搭建房间之前，我们不是瞎摆，而是先用一种技术（SfM）处理一堆房间的照片，得到一些房间里关键特征点的3D位置。这些点可能不多，比较稀疏，就像一个大致的骨架。然后，我们就在这些骨架点的位置上，放置我们最初的“3D小云彩”。

*   **专业名词和具体内容：**
    1.  **运动恢复结构 (Structure from Motion, SfM)：**
        *   **含义：** 这是一种摄影测量技术。你给它一堆从不同角度拍摄的同一个场景的照片，它就能分析这些照片，自动计算出每张照片拍摄时的相机位置和姿态，同时还能估算出场景中一些稳定特征点在三维空间中的位置。
        *   **作用：** 提供初始的3D结构信息。

    2.  **稀疏点云 (Sparse Point Cloud)：**
        *   **含义：** SfM处理后得到的就是一堆三维空间中的点，这些点云通常只包含场景中比较明显的特征，数量相对较少，所以叫“稀疏”点云。它不像最终模型那样细节丰富，但能给出一个大致的轮廓。具体会给出表示放在哪里和朝向哪里的6个自由度也就是6DoF与相对的尺度信息。
        *   **作用：** 作为3D高斯初始化的基础。

    3.  **初始化 (Initialize)：**
        *   **含义：** 就是给我们的“3D小云彩”设定一个最初始的状态。我们会把第一个“小云彩”放在第一个SfM点的位置，它的初始颜色可能就是那个SfM点的颜色，初始形状（协方差）会根据它和周围其他SfM点的距离来大致估算一个大小。
        *   **作用：** 提供一个比随机猜测好得多的起点，让后续的优化过程更快、效果更好。

---

**核心思想 3：在优化过程中，交替进行高斯参数的优化和自适应的密度控制（即增加或删除高斯）。**

*   **大白话解释：**
    有了初始的“小云彩”后，电脑就开始学习和调整。它会不断地对比用这些“小云彩”画出来的图像和真实照片的差异，然后一点点修改每个“小云彩”的参数（位置、形状、颜色、透明度），让画出来的越来越像真的。同时，它还会智能地判断：如果某个地方细节不够，就多放几个“小云彩”；如果某个“小云彩”没什么用，或者太碍事，就把它删掉。这两件事是轮流进行的。

*   **专业名词和具体内容：**
    1.  **优化过程 (Optimization Process)：**
        *   **含义：** 这是一个学习过程，目标是调整所有3D高斯的参数，使得通过这些高斯渲染出来的图像与输入的真实照片尽可能相似。
        *   **方法：** 通常使用梯度下降算法。计算渲染图像与真实图像之间的差异（损失函数），然后根据这个差异反向计算每个高斯参数应该如何调整才能减小这个差异。

    2.  **交替进行 (Alternating)：**
        *   **含义：** 指的是“优化高斯参数”和“自适应密度控制”这两个步骤不是一次性完成，而是轮流着来。比如，先优化几轮参数，然后做一次密度控制，再继续优化参数，再做密度控制……

    3.  **高斯参数的优化 (Optimization of Gaussian parameters)：**
        *   **含义：** 就是微调每个3D高斯的位置 $μ$、形状（通过缩放 $s$ 和旋转 $q$）、不透明度 $α$ 以及颜色（球谐系数 $c_{sh}$），使得整体渲染效果更好。

    4.  **自适应的密度控制 (Adaptive Density Control)：**
        *   **含义：** 根据场景的复杂度和重建的需要，智能地调整3D高斯的数量和分布。
        *   **增加高斯 (Densification)：**
            *   **克隆 (Cloning)：** 如果一个高斯所在的区域细节不足（表现为优化时这个高斯的位置梯度很大，说明系统想把它“拉扯”开以覆盖更大区域），系统就会复制这个高斯，并把复制出来的新高斯稍微移动一点。
            *   **分裂 (Splitting)：** 如果一个高斯太“胖”了（覆盖了太大的范围，可能导致细节模糊），系统就会把它分裂成两个或多个更小的高斯，以表达更精细的结构。
        *   **删除高斯 (Pruning)：** 如果一个高斯几乎完全透明（$α$ 值非常接近0），说明它对最终图像没什么贡献，就可以删掉它以节省计算资源。或者一些尺寸异常（过大或过小）的高斯也可能被移除。

---

**核心思想 4：开发了一个快速的、可微分的基于瓦片（tile-based）的光栅化器，能够高效地将3D高斯“泼溅”（splatting）到图像平面上。**

*   **大白话解释：**
    为了能很快地把这些3D“小云彩”画到你的2D电脑屏幕上，研究者们专门设计了一个非常高效的“绘画引擎”（光栅化器）。这个引擎有两个特点：
    1.  **快 (Fast) 且 基于瓦片 (Tile-based)：** 它把屏幕分成一小块一小块的“瓦片”（像地砖一样），然后一块一块地画，这样效率很高。所谓“泼溅”（splatting），你可以想象每个3D“小云彩”就像一个蘸了颜料的、有特定形状的刷子，这个引擎能快速地把这些“刷子”按照正确的顺序（近的盖住远的）“印”或者“泼”到屏幕的“瓦片”上。
    2.  **可微分 (Differentiable)：** 这对AI学习非常重要。意思是，当AI稍微调整一下某个“小云彩”的参数时，这个“绘画引擎”能告诉AI，这个调整对最终画出来的图像会产生什么样的具体影响（梯度的概念）。这样AI才知道下一步该怎么调整才能让图像更好。

*   **专业名词和具体内容：**
    1.  **快速的 (Fast)：** 目标是实现实时渲染，即每秒能画出很多帧图像，让你感觉流畅。

    2.  **可微分的 (Differentiable)：**
        *   **含义：** 指光栅化（绘画）过程中的所有计算步骤对于输入的3D高斯参数都是可以求导数的。这意味着，如果高斯参数发生微小变化，我们可以计算出最终渲染图像的像素值会如何相应地变化。
        *   **作用：** 这是通过梯度下降优化高斯参数的基础。只有可微分，才能计算损失函数对高斯参数的梯度，从而指导优化方向。

    3.  **基于瓦片 (Tile-based) 的光栅化器 (Rasterizer)：**
        *   **光栅化器 (Rasterizer)：** 这是图形渲染管线中的一个核心组件，它的任务是将场景的几何描述（在这里是3D高斯）转换成屏幕上实际的像素颜色。
        *   **基于瓦片 (Tile-based)：** 传统的光栅化器可能一次处理一个图元（比如一个三角形或一个高斯）对整个屏幕的影响。而基于瓦片的光栅化器则是先将屏幕划分成许多个小矩形区域（瓦片，例如16x16像素）。然后，对于每个瓦片，找出所有可能影响到这个瓦片的3D高斯，再在瓦片内部进行排序和混合颜色。这种方式通常能更好地利用GPU的并行计算能力和缓存，提高渲染效率。

    4.  **泼溅 (Splatting)：**
        *   **含义：** 这是一种渲染技术，尤其适用于点状或模糊状的图元。每个3D高斯在投影到2D图像平面后，会形成一个2D的椭圆形区域（一个“splat”）。渲染时，就是将这些2D椭圆的颜色和不透明度按照从后往前的顺序（或者从前往后的顺序，配合alpha混合）累积到像素上。
        *   **作用：** 一种直接将3D高斯贡献绘制到图像上的方法。

    5.  **图像平面 (Image Plane)：**
        *   **含义：** 就是你的2D电脑屏幕，或者说渲染目标图像所在的那个二维平面。

# $\dagger$ 上述内容就是对于核心思想的一个大致的、通俗地描述，现在，我们即将开始阅览和理解这篇3D高斯泼溅的震撼思想，同时也要明白：一切好的思路都是踩在巨人的肩膀上给出的，现在我们就开始探索吧————

### 1.2 引言 (Introduction)

引言部分首先回顾了神经辐射场（NeRF）的成功，它在从一组输入图像合成新视角方面取得了巨大突破。然而，NeRF及其后续改进方法通常需要较长的训练时间，并且渲染速度较慢，难以满足实时应用的需求。接着，论文讨论了其他加速渲染的方法，包括一些基于显式表示（如点云或体素）的方法。这些方法通常渲染速度更快，但可能在细节和真实感上不如NeRF。论文指出，他们工作的目标是结合显式表示的速度优势和隐式表示的高质量。他们认为，使用3D高斯作为场景的基本表达单元，可以有效捕捉场景的几何和外观，并通过专门设计的优化和渲染管线，实现质量和速度的双赢。
主要贡献可以概括为：
1.  提出使用各向异性的3D高斯函数作为场景的灵活表示。
2.  设计了一套优化策略，包括高斯参数（位置、协方差、不透明度、球谐系数）的优化，以及穿插进行的自适应密度控制（高斯的克隆、分裂和剪枝）。
3.  实现了一个高效的基于GPU的瓦片光栅化器，支持各向异性高斯的快速渲染，并且整个过程是可微分的，允许通过反向传播进行优化。

### 1.3方法 (Method)**

这是论文的核心部分，详细描述了3D高斯溅射技术如何工作。

1.  **用3D高斯表示场景 (Representing Scenes with 3D Gaussians)**
    *   **高斯定义**：场景由数百万个3D高斯函数构成。每个高斯函数由以下参数定义：
        *   **位置 (均值, μ)**：一个三维向量 (x, y, z)，表示高斯的中心，表示的是分布在三个坐标轴下的平均位置。
        *   **协方差矩阵 (Covariance, Σ)**：一个3x3的矩阵，描述了高斯的形状和方向，反映的是分布在不同方向上扩散情况。表示如下：
        ![alt text](image-19.png)，其中的$\sigma{xx,yy,zz}$代表xyz轴上分方差，而其他元素表示不同轴之间的协方差。
        ~~~python
        方差和协方差的关系：方差是描述单个随机变量波动程度的量度，而协方差是描述两个随机变量如何一起拜年话的量度，在协方差矩阵中，对角线元素也就是描述了各个轴上的分布宽度，而非对角线元素则描述着不同轴之间的相关性。
        ~~~
        论文中不直接存储和优化完整的协方差矩阵，而是存储一个3D缩放向量 **s** (scale) 和一个表示旋转的四元数 **q** (rotation)。协方差矩阵可以由 $Σ =R SSᵀRᵀ$ 构成，其中 $R$ 是从 **q** 得到的旋转矩阵，$S$ 是由 **s** 构成的对角缩放矩阵。这种表示允许高斯是各向异性的，即可以在不同方向上拉伸或压缩，从而更好地拟合表面。
        *   **不透明度 (Opacity, α)**：一个标量，表示该高斯对光线的阻挡程度。
        *   **颜色 (Color)**：通过球谐函数 (Spherical Harmonics, SH) 的系数来表示。球谐函数可以捕捉视角相关的颜色变化（例如镜面反射），从而使渲染结果更真实。通常使用较低阶（例如2阶或3阶）的球谐函数。

    *   **初始化**：这些3D高斯通常从SfM算法产生的稀疏点云初始化。每个SfM点会初始化一个高斯，其初始位置就是点的位置，初始颜色是点的颜色，初始不透明度设置得较低，初始协方差根据该点到最近邻点的距离来估计，使其大致覆盖点周围的空间。

2.  **可微分光栅化 (Differentiable Rasterization)**
    这个步骤是将3D高斯投影到2D图像平面上并生成最终图像的过程，且整个过程对于高斯参数是可微分的，这样才能通过梯度下降来优化它们。
    *   **投影**：对于给定的相机视角（由视图矩阵 $W$ 和投影矩阵 $K$ 定义），每个3D高斯会被投影到2D图像平面上。一个3D高斯投影后仍然是一个2D高斯。其2D协方差矩阵 $Σ'$ 可以通过 $Σ' = J Σ Jᵀ$ 计算得到，其中 $J$ 是从3D高斯中心到2D图像平面的仿射变换的雅可比矩阵。
    ~~~python
    不采用直接投影而是采用透视投影，如果采用透视投影变换将会直接导致形状是扭曲的，因为透视投影是非线性的，近处的物体看起来大，而远处的物体看起来小，这种变化是不均匀的，既然整体的透视投影太复杂了，就采用局部线性化处理，而雅各比矩阵就是放大的局部放大镜，能够告诉我们在某一个特定位置，在3D空间中的一个小变化在2D屏幕上会有多大的变化。这里也是因为雅各比矩阵是一堆一阶导数构成，本身一阶导数的含义不就是当自变量具有一个微小的变量时候的因变量也就是函数值的变化情况吗？
    ~~~
    *   **瓦片光栅化器 (Tile-based Rasterizer)**：为了实现高速渲染，论文设计了一个基于瓦片的GPU光栅化器。
        *   首先，会进行视锥剔除和初步的深度测试，去除不可见的高斯。
        *   然后，屏幕被划分为多个小瓦片（tiles，例如16x16像素）。每个高斯会被分配到它所覆盖的瓦片中。
        *   在每个瓦片内部，覆盖该瓦片的高斯会根据其深度进行排序。
        *   最后，对于瓦片中的每个像素，按照从前到后的顺序混合（alpha blending）排序后的高斯颜色和不透明度，得到像素的最终颜色。
    *   **颜色混合 (Alpha Blending)**：对于一个像素，其最终颜色 $C$ 是由所有覆盖该像素的 $N$ 个已排序（从前到后）的高斯的颜色 $cᵢ$ 和有效不透明度 $αᵢ'$ 混合而成：
        $C = Σᵢ (αᵢ' cᵢ Πⱼ<ᵢ (1 - αⱼ'))$
        其中 $αᵢ'$ 是第 $i$ 个高斯在该像素处贡献的不透明度，它是高斯学习到的不透明度参数和其2D高斯形状在该像素处的值的乘积。$Πⱼ<ᵢ (1 - αⱼ')$ 表示累积的透明度，即光线穿过前面 $j$ 个高斯的概率。
    *   **快速反向传播**：该光栅化器也支持快速准确的梯度计算，这对于优化至关重要。

3.  **优化 (Optimization)**
    优化的目标是调整所有高斯的参数（位置 **μ**，缩放 **s**，旋转 **q**，不透明度 **α**，以及球谐系数），使得渲染出来的图像与训练视图的真实图像尽可能一致。
    *   **损失函数 (Loss Function)**：通常使用L1损失和D-SSIM（结构相异性指数）的组合：
        $L = (1 - λ) * L_L1 + λ * L_D-SSIM$
        其中 $L_L1$ 是渲染图像和真实图像之间的L1范数（像素绝对差之和），$L_D-SSIM = (1 - SSIM) / 2$，$SSIM$ 是结构相似性指数。$λ$ 是一个权重因子，论文中常设为0.2。
    *   使用随机梯度下降（SGD）或其变体（如Adam）进行优化。

4.  **自适应密度控制 (Adaptive Density Control of Gaussians)**
    这是获得高质量结果的关键步骤。仅仅优化初始化的稀疏高斯通常不足以表达场景的所有细节。因此，在优化过程中，会周期性地（例如每100次迭代）进行高斯的自适应控制：
    *   **致密化 (Densification)**：
        *   **克隆 (Cloning)**：对于那些在视图空间中具有较大位置梯度的高斯（意味着它们被优化器强烈地“拉扯”，表明它们所在的区域重建得不好，需要更多细节），会复制一份，并将复制体沿着梯度的方向轻微移动。
        *   **分裂 (Splitting)**：对于那些尺寸过大（即缩放因子 **s** 较大）的高斯，它们会被分裂成两个更小的高斯。它们的尺寸会减小，并被放置在原高斯位置附近。这有助于捕捉更精细的几何细节。
        新的高斯通常会继承父高斯的属性，但尺寸会减小，不透明度可能会被重置为一个较小的值。
    *   **剪枝 (Pruning)**：移除那些几乎完全透明（不透明度 **α** 极低）的高斯，或者那些在屏幕空间中投影尺寸过大或过小（超出一定阈值）的高斯，因为它们对最终图像的贡献很小，或者可能是优化过程中的一些无用产物。

    这个自适应控制过程使得高斯能够根据需要“生长”到场景中细节丰富或重建不足的区域，同时去除冗余或不重要的高斯，从而动态地优化场景的表示。

**关键公式理念 (Key Formula Concepts)**

*   **3D高斯函数本身 (Unnormalized Gaussian for rendering focus):**
    $G(x; μ, Σ) ∝ exp(-0.5 * (x-μ)ᵀ Σ⁻¹ (x-μ))$
    这里 $x$ 是空间中的一点，$μ$ 是高斯中心，$Σ$ 是协方差矩阵。在渲染时，主要关心的是指数部分决定的形状和学习到的不透明度 $α$。

*   **协方差的分解与参数化:**
    $Σ = R S Sᵀ Rᵀ$
    通过优化旋转四元数 **q** (得到 $R$) 和缩放向量 **s** (得到对角矩阵 $S$) 来控制高斯的各向异性形状，这比直接优化9个自由度的对称协方差矩阵更稳定和高效。

*   **2D投影协方差:**
    $Σ' ≈ J Σ Jᵀ$
    这是理解3D高斯如何影响2D图像的关键。$J$ (雅可比矩阵) 捕获了从3D高斯中心附近的点到2D图像的局部仿射变换。

*   **颜色混合公式 (Alpha Blending, conceptual):**
    $C_pixel = Σ (current_gaussian_color * current_gaussian_alpha_at_pixel * transparency_from_gaussians_in_front)$
    这是一种标准的从前到后的颜色合成方法。

*   **损失函数组合:**
    $Loss = weight_L1 * L1_difference + weight_DSSIM * (1 - Structural_Similarity)$
    结合像素级别的直接差异和感知上的结构差异，以获得更好的视觉效果。

**实验结果 (Results)**

论文展示了在多个具有挑战性的数据集上的广泛实验结果，包括合成数据集（如NeRF Synthetic）和真实世界场景（如LLFF, Tanks and Temples, Mip-NeRF 360等）。
*   **渲染质量**：在PSNR、SSIM和LPIPS等标准度量上，3D高斯溅射方法通常能达到与最先进的基于NeRF的方法（如Mip-NeRF 360, Instant-NGP）相当甚至更好的结果。图像通常非常清晰，细节丰富。
*   **渲染速度**：这是最引人注目的成果。该方法可以在1080p或更高分辨率下实现实时渲染（例如，在NVIDIA RTX 3090或4090等GPU上，可以达到几十到上百FPS），这对于以前的高质量方法来说是难以想象的。
*   **训练时间**：训练时间也相对较短，通常在几十分钟到一个小时内就能在单个GPU上获得高质量结果，这比许多NeRF变体要快得多。
*   **模型大小**：虽然场景由数百万个高斯表示，但每个高斯参数量不大，最终模型大小是可控的。

**结论 (Conclusion)**

《3D Gaussian Splatting》提出了一种创新且高效的方法，用于从图像集合中学习场景的高质量表示，并能实时渲染新视角。
它通过引入各向异性3D高斯作为场景基元，结合专门设计的可微分光栅化管线和自适应密度控制策略，成功地平衡了渲染质量和速度。

这项工作的主要贡献在于：
1.  证明了显式的、基于高斯的表示可以达到与隐式神经表示相媲美的质量。
2.  实现了前所未有的高质量场景实时渲染。
3.  提供了一套完整的、从初始化到优化再到渲染的流程。

该方法为许多需要高质量实时3D场景渲染的应用（如VR/AR、游戏、数字孪生等）开辟了新的可能性。未来的工作可能包括进一步压缩高斯表示、处理动态场景、改进自适应控制策略等。

希望这个详细的介绍能帮助您理解这篇重要的论文！


### $\dagger$ 通俗白话介绍
好的，咱们用大白话聊聊这个“3D GS”技术是干啥的，特别是那三个关键部分。

想象一下，你想把一个真实的场景（比如你的房间或者一个公园）完整地“复制”到电脑里，不仅能看，还能像玩游戏一样实时地在里面转悠，感觉非常逼真。这个 "3D GS" 就是一种实现这个目标的新方法。它主要靠三个“法宝”：

**法宝一：用一堆特殊的3D“小墨点”（或者叫“小云彩”）来描绘场景**

*   **这是啥：** 它不是用传统的几何模型（比如方块、球体），而是用很多很多被称为“3D高斯函数”的东西来表示场景。你可以把这些“高斯函数”想象成一团团彩色的、有一定形状（可以是圆的，也可以是椭圆的，像个鸡蛋一样）、有透明度的小墨点或小云彩。
*   **怎么开始：** 研究人员会先用几张照片，通过一种叫“从运动中恢复结构”（SfM）的技术，大致估算出场景里一些点的3D位置，得到一个稀疏的点云。然后，他们就用这些点作为初始位置，生成一堆这样的“小墨点”。
*   **牛在哪儿：**
    *   这些“小墨点”非常灵活，能很好地表现物体的细节和材质。
    *   相比一些老方法需要非常密集的初始点云，这个方法用比较少的点（稀疏点云）就能做出高质量的效果，甚至在某些情况下，随机初始化这些“小墨点”也能行。
    *   把这些3D的“小墨点”画到2D屏幕上（这个过程叫“光栅化”）非常快，而且它们本身的数学特性（可微分）也特别适合用AI来学习和优化，让最终图像效果更好。

**法宝二：聪明地调整和管理这些“小墨点”**

*   **干了啥：** 有了这些“小墨点”之后，电脑会非常精细地调整它们各自的属性：
    *   **3D位置：** 每个“小墨点”在空间里的精确位置。
    *   **不透明度：** 这个“小墨点”是实的还是半透明的。
    *   **形状和方向（各向异性协方差）：** 这个“小墨点”是圆的还是扁的，朝向哪个方向。这能更好地表现物体的表面。
    *   **颜色和光泽（球谐函数系数）：** 从不同角度看，这个“小墨点”的颜色和亮度是怎么变化的。这能让光照和反光看起来更真实。
*   **动态增删（自适应密度控制）：** 在优化的过程中，系统还会智能地：
    *   **增加“小墨点”：** 如果发现场景的某个地方细节不够，就在那里加一些新的“小墨点”。
    *   **删除“小墨点”：** 如果有些“小墨点”是多余的，或者对最终效果没什么帮助，就把它去掉。
*   **结果：** 经过这一系列操作，就能得到一个既精确又能高效表示场景的“小墨点”集合。虽然数量可能听起来很多（比如几百万个），但相对于场景的复杂度和真实感来说，这已经算是很紧凑了。

**法宝三：把这一切超快地“画”出来，让你实时看到**

*   **目标：** 就是让你在电脑屏幕上能流畅地、没有卡顿地看到这个3D场景，并且可以自由移动视角。
*   **怎么做到：**
    *   **快速排序：** 利用显卡（GPU）的强大计算能力，把所有的“小墨点”按照离你眼睛从远到近的顺序快速排好。这样才能保证近处的物体挡住远处的物体，看起来才对。
    *   **高效“喷溅”（符合可见性顺序的各向异性喷洒）：** 因为每个“小墨点”都有自己的3D形状和朝向，系统可以很高效地把它们按照排好的顺序，“喷溅”或者说“印”到你的2D屏幕上，并且正确地混合它们的颜色和透明度。
    *   **帮助AI快速学习：** 这种渲染方法还有一个好处，就是能帮助AI更快地学习怎么调整那些“小墨点”的参数。当AI尝试改变一个“小墨点”时，它需要知道这个改变会对最终图像产生什么影响，这个渲染方法能让这个计算过程（反向传播）变得又快又准。

**简单总结一下：**

这个技术就是用一大堆智能的、可调节的3D“小墨点”来代表一个真实场景。它有一套聪明的方法来精细调整这些“小墨点”（位置、形状、颜色、透明度等），并且在需要的时候增加或删除它们，最终得到一个高质量又相对简洁的场景数据。最后，它还有一种超快的技术能把这些“小墨点”实时地画在你的屏幕上，让你能身临其境地体验这个3D场景。

### 公式相关推导

## 基于3D高斯的方法 【夯基石】

## AnySplat方法 【应用创新点】
